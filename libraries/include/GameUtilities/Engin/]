#include "GameUtilities/Engin/Engin.h"

#include <cassert>
#include <stack>

namespace GU
{

    namespace Engin
    {


        /*************************************************************************
        *   @author Wayne J Larson Jr.
        *   @brief  Implimentation of the Engin class.
        *   @date   3/20/18
        *************************************************************************/
		class Engin::Impl
		{
			public:
				typedef GU::Engin::Engin::StatePtr StatePtr; //pointer to gamestate

                /********************************************************************
                *   @brief  Constructor
                *   @param  engin is a reference to the parent GU::Engin::Engin
                *           class.
                ********************************************************************/
                Impl(GU::Engin::Engin &engin);


                Impl(Impl&& param):
                m_engin(param.m_engin),
                m_running(param.m_running)
                {
                    states = std::move(param.states);
                    m_running = param.m_running;
                }

                Impl& operator=(Impl&& param)
                {
                    if (this != &param)
                    {
                        states = std::move(param.states);
                        m_running = param.m_running;
                    }
                    return *this;
                }


                int size() const
                {
                    return states.size();
                }
                /********************************************************************
                *   @brief  Destructor
                ********************************************************************/
                virtual ~Impl();
			private:
				//stack of states the state on the top of the stack is the current state
				std::stack<StatePtr> states;

                //Referece to an Engin object
				GU::Engin::Engin &m_engin;

				//true while the game is running and false otherwise
				bool m_running = true;
		};


        /********************************************************************
        *   @brief  Constructor
        *   @param  engin is a reference to the parent GU::Engin::Engin
        *           class.
        ********************************************************************/
        Engin::Impl::Impl(GU::Engin::Engin &engin):
        m_engin(m_engin),
        m_running(true)
        {
        }


        /********************************************************************
        *   @brief  Destructor
        ********************************************************************/
        Engin::Impl::~Impl()
		{

		}


        /*********************************************************************************//**
        *   @brief	Default constructor
        *************************************************************************************/
        Engin::Engin(): pimpl(new Engin::Impl(*this))
        {
            //ctor

        }



        Engin::Engin(Engin&& param)
        {
            if(pimpl)
                delete pimpl;

            pimpl = param.pimpl;
            param.pimpl = nullptr;
        }


        Engin& Engin::operator=(Engin&& param)
        {
            assert(pimpl != nullptr);
            assert(param.pimpl != nullptr);
            pimpl = param.pimpl;

			return *this;
        }

        /*********************************************************************************//**
        *	@brief	Push a new state onto the stack.
        *   @param	state a pointer to a GameState object.
        *************************************************************************************/
        void Engin::push(StatePtr state)
        {
            assert(pimpl != nullptr);
			assert(pimpl->state != nullptr);

			if (!pimpl->states.empty())
			{
				pimpl->states.top()->pause();
				pimpl->states.top()->clean();
			}

			pimpl->states.push(std::move(state));
			pimpl->states.top()->init();
        }


        /*********************************************************************************//**
        *   @brief Remove a state from the stack
        *   @return boolean true when the state is successfully removed
        *           from the stack.
        *************************************************************************************/
        bool Engin::pop()
        {
            assert(pimpl != nullptr);
			
            if(pimpl->states.empty())
			{
				return false;
			}


			pimpl->states.top()->clean();
			pimpl->states.pop();

			if (!pimpl->states.empty())
			{
				pimpl->states.top()->init();
				pimpl->states.top()->pause(false);
			}

			return true;
        }


        /*********************************************************************************//**
        *   @brief 	Remove any existing GameState objects from the stack, and push
        *           A new GameState object onto the stack.
        *   @param	state a pointer to a GameState object.
        *************************************************************************************/
        void Engin::changeState(StatePtr state)
        {
			assert(state != nullptr);


			///Remove any existing states
			while (!pimpl->states.empty())
				this->pop();

			///Push the state onto the now empty stack
			this->push(std::move(state));
        }


        /*********************************************************************************//**
        *   @brief	This method is used to determine if the game is still running.
        *	@return boolean true when the game is running and false otherwise
        *************************************************************************************/
        bool Engin::isRunning() const
        {
            assert(pimpl != nullptr);
			return pimpl->m_running;
        }


        /*********************************************************************************//**
        *   @brief	This method is used to end the game.
        *
        *	@return	After calling this method IsRunning() returns false.
        *************************************************************************************/
        void Engin::quit()
        {
            assert(pimpl != nullptr);
			pimpl->m_running = false;
        }

        bool Engin::empty() const
        {
            assert(pimpl != nullptr);
            return pimpl->states.empty();
        }
        /********************************************************************
        *   @brief  This method handles all types of input.
        *   @param  deltaTime is the time the previous frame took
        *           See Engin::HendleEvents
        ********************************************************************/
		void Engin::Impl::handleEvents(const float &deltaTime)
		{
		}

        /*********************************************************************************//**
        *   @brief	This method is used to call an equivalent method in a GameState
        *           class. Which will have code for handling all kinds of input
        *           include events and user input.
        *   @param  deltaTime is the time the previous frame took
        *************************************************************************************/
        void Engin::handleEvents(const float &deltaTime)
        {
            assert(pimpl != nullptr);
			assert(!pimpl->states.empty());

			///Call the current states HandleEvents method.
			pimpl->states.top()->handleEvents(pimpl->m_engin, deltaTime);
        }


        /*********************************************************************************//**
        *   @brief	 This method is used to call an equivalent method in a GameState
        *            class. Which will have code for handling game logic.
        *   @param  deltaTime is the time the previous frame took
        *************************************************************************************/
        void Engin::update(const float &deltaTime)
        {
            assert(pimpl != nullptr);
			assert(!pimpl->states.empty());

			///Call the current states Update method.
			pimpl->states.top()->update(pimpl->m_engin, deltaTime);
        }

        /********************************************************************
        *   @brief  This method draws the current frame.
        *   @param  deltaTime is the time the previous frame took
        *           See Engin::Draw
        ********************************************************************/
		void Engin::Impl::draw(const float &deltaTime)
		{
		}

        /*********************************************************************************//**
        *   @brief	Remove any existing GameState objects from the stack, and push
        *           A new GameState object onto the stack. The new state will be
        *           created internally the user specifies the type of state, and
        *           passes any arguments needed by the states constructor.
        *   @param  StatePtr a pointer to a GameState object.
        *   @param  deltaTime is the time the previous frame took
        *************************************************************************************/
        void Engin::draw(const float &deltaTime)
        {
            assert(pimpl != nullptr);
			assert(!pimpl->states.empty());

			///Call the current states Draw method.
			pimpl->states.top()->draw(pimpl->m_engin, deltaTime);
        }

        int Engin::size() const
        {
            assert(pimpl != nullptr);
            return pimpl->size();
        }

        /*********************************************************************************//**
        *   @brief	Destructor:
        *************************************************************************************/
        Engin::~Engin()
        {
            //dtor
            if(pimpl != nullptr)
            {
                delete pimpl;
                pimpl = nullptr;
            }
        }
    }

}
